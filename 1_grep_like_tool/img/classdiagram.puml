@startuml
namespace core {
    class Request << (S,Aquamarine) >> {
        + Paths []string
        + Recursive bool
        + Search line_output.SearchInfo
        + FileOutput file_output.FileOutputRequest
        + LinePrefix line_prefix_output.LinePrefixRequest

        + IsRecursive() bool
        + GetPaths() []string

    }
}

"file_scanner.ScannableContent" <|-- "core.Request"

"core.Request" o-- "file_output.FileOutputRequest"
"core.Request" o-- "line_output.SearchInfo"
"core.Request" o-- "line_prefix_output.LinePrefixRequest"

namespace engine {
    class Engine << (S,Aquamarine) >> {
        - ls LineSelector
        - flm FileLevelMotor
        - fpm FilePrefixMotor

        + OutputOnLine(line string, filename string) string
        + OutputOnWholeFile(filename string) string

    }
    interface FileLevelMotor  {
        + ProcessLine(selected_line string, filename string) string
        + GetFileLevelResult(filename string) string

    }
    interface FilePrefixMotor  {
        + GetPrefix(filename string) string

    }
    interface LineSelector  {
        + GetResult(line string) string

    }
}

"file_scanner.Finder" <|-- "engine.Engine"


namespace file_output {
    class FileOutputRequest << (S,Aquamarine) >> {
        - filesWithoutMatchMap <font color=blue>map</font>[string]bool
        - filesWithMatchMap <font color=blue>map</font>[string]bool
        - countMatchingLinesMap <font color=blue>map</font>[string]int

        + CountLines bool
        + FilesWithoutMatch bool
        + FilesWithMatch bool

    }
    class FileOutputSelector << (S,Aquamarine) >> {
        + Fo *FileOutputRequest

        - suppressNormalOutput() bool

        + ProcessLine(line string, filename string) string
        + GetFileLevelResult(filename string) string

    }
}

"engine.FileLevelMotor" <|-- "file_output.FileOutputSelector"

"file_output.FileOutputSelector" o-- "file_output.FileOutputRequest"

namespace file_scanner {
    class FileScanner << (S,Aquamarine) >> {
        - printOut *io.Writer
        - printErr *io.Writer

        + Finder Finder
        + Content ScannableContent

        - collectOutput(filesOut <font color=blue>chan</font> <font color=blue>chan</font> typedMsg, result <font color=blue>chan</font> bool) 
        - processFile(filename string, workersCh <font color=blue>chan</font> bool, filesOut <font color=blue>chan</font> <font color=blue>chan</font> typedMsg, workersWg *sync.WaitGroup) 
        - processError(filesOut <font color=blue>chan</font> <font color=blue>chan</font> typedMsg, err error) 
        - processFileConc(filename string, currentFileOut <font color=blue>chan</font> typedMsg, workersCh <font color=blue>chan</font> bool, workersWg *sync.WaitGroup) 

        + GoThroughFiles() 

    }
    interface Finder  {
        + OutputOnLine(line string, filename string) string
        + OutputOnWholeFile(filename string) string

    }
    interface ScannableContent  {
        + IsRecursive() bool
        + GetPaths() []string

    }
    class typedMsg << (S,Aquamarine) >> {
        - content string
        - isErr bool

    }
}


"file_scanner.FileScanner" o-- "file_scanner.Finder"
"file_scanner.FileScanner" o-- "file_scanner.ScannableContent"

namespace line_output {
    class LineSelector << (S,Aquamarine) >> {
        - regexp *regexp.Regexp
        - regexCaseSensitive *regexp.Regexp

        - lineSelectorPipeline(line string) highlightedLine
        - applyMatchGranularity(line string, indexes [][]int) [][]int
        - applyCaseSensitiveSelection(line string, indexes [][]int) [][]int
        - getMatchingPatternIndexes(line string) [][]int

        + GetResult(line string) string

    }
    class SearchInfo << (S,Aquamarine) >> {
        + Pattern string
        + CaseInsensitive bool
        + InvertMatching bool
        + Granularity matchGranularity
        + OnlyMatching bool

    }
    class highlightedLine << (S,Aquamarine) >> {
        - line string
        - keywordRanges [][]int

    }
    class line_output.matchGranularity << (T, #FF7700) >>  {
    }
}
"line_output.SearchInfo" *-- "line_output.LineSelector"

"engine.LineSelector" <|-- "line_output.LineSelector"

"line_output.SearchInfo" o-- "line_output.matchGranularity"

namespace line_prefix_output {
    class LinePrefixRequest << (S,Aquamarine) >> {
        + WithFilename bool

    }
    class LinePrefixSelector << (S,Aquamarine) >> {
        + Lpr *LinePrefixRequest

        + GetPrefix(filename string) string

    }
}

"engine.FilePrefixMotor" <|-- "line_prefix_output.LinePrefixSelector"

"line_prefix_output.LinePrefixSelector" o-- "line_prefix_output.LinePrefixRequest"

namespace parser {
    class InputModel << (S,Aquamarine) >> {
        + Pattern string
        + Paths []string

    }
    class InputOptions << (S,Aquamarine) >> {
        + Recursive bool
        + IgnoreCase bool
        + InvertMatch bool
        + WordRegexp bool
        + LineRegexp bool
        + OnlyMatching bool
        + Count bool
        + FilesWithoutMatch bool
        + FilesWithMatches bool
        + WithFilename bool

    }
}
"parser.InputOptions" *-- "parser.InputModel"



"__builtin__.int" #.. "line_output.matchGranularity"
@enduml
